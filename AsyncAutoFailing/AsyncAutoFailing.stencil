{% macro getCleanTypeName typeName %}
    {% if typeName|contains: "Interface" %}
        {{ typeName|replace: "Interface", ""}}
    {% elif typeName|contains: "Protocol" %}
        {{ typeName|replace: "Protocol", ""}}
    {% endif %}
{% endmacro %}

{% macro resolveReturnValueForReturnType method %}
    {% set foundationTypesWithNoFixture %} 
    [
        "Date", "Data", "URL"
    ]
    {% endset %}
    {% if method.returnType.kind == "enum" %}
        .{{ method.returnType.cases.first.name }}
    {% elif foundationTypesWithNoFixture|contains: method.returnTypeName %}
        .init()x
    {% else %}
        {% if method.returnTypeName|contains:"[" and method.returnTypeName|contains:"]" %}
            .init()
        {% else %}
            .fixture()
        {% endif %}
    {% endif %}
{% endmacro %}

{% for type in types.protocols %}{# Use types.implementing.AsyncAutoFailing instead of types.protocols if decided to have this protocol #}
{% newline %}
import XCTestDynamicOverlay

// MARK: - {{ type.name }}Failing

{% set cleanTypeName %} {% call getCleanTypeName type.name %}  {% endset %}
public struct {{ cleanTypeName|removeNewlines }}Failing: {{ type.name }} {
    public init() {}
    {% for method in type.allMethods %}

    public func {{ method.name }} async throws {% if method.returnTypeName.name != "Void" %}-> {{ method.returnTypeName.name }} {% endif %}{
        XCTFail("\(#function) is not implemented.")
        {% if method.returnTypeName.name != "Void" %}
        {% set returnValue %} {% call resolveReturnValueForReturnType method %} {% endset %}
        return {{ returnValue|removeNewlines }}
        {% endif %}
    }
    {% endfor %}
}
#endif

{% endfor %}