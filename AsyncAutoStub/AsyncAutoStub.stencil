{% macro getCleanTypeName typeName %}
    {% if typeName|contains: "Interface" %}
        {{ typeName|replace: "Interface", ""}}
    {% elif typeName|contains: "Protocol" %}
        {{ typeName|replace: "Protocol", ""}}
    {% endif %}
{% endmacro %}

{% macro resolveReturnValueForReturnType method %}
{% typed method as Method %}
    {% set foundationTypesWithNoFixture %} 
    [
        "Date", "Data", "URL"
    ]
    {% endset %}
    {% if method.returnType.kind == "enum" %}
        .{{ method.returnType.cases.first.name }}
    {% elif foundationTypesWithNoFixture|contains: method.returnTypeName %}
        .init()
    {% else %}
        {% if method.returnTypeName|contains:"[" and method.returnTypeName|contains:"]" %}
            .init()
        {% else %}
            .fixture()
        {% endif %}
    {% endif %}
{% endmacro %}

{% for type in types.protocols %}{# Use types.implementing.AsyncAutoStub instead of types.protocols if decided to have this protocol #}
// MARK: - {{ type.name }}Stub

{% set cleanTypeName %} {% call getCleanTypeName type.name %}  {% endset %}
{{ type.accessLevel }} final class {{ cleanTypeName|removeNewlines }}Stub: {{ type.name }} {
    {{ type.accessLevel }} init() {}
    {% for method in type.allMethods %}

    // MARK: - {{ method.shortName }}

    {% if method.returnTypeName.name != "Void" %}
    {% set returnValue %} {% call resolveReturnValueForReturnType method %} {% endset %}
    {{ type.accessLevel }} var {{ method.shortName }}ResultToBeReturned: Result<{{ method.returnTypeName.name }}, Error> = .success({{ returnValue|removeNewlines }})
    {% else %}
    {{ type.accessLevel }} var {{ method.shortName }}ResultToBeReturned: Result<Void, Error> = .success(())
    {% endif %}
    {{ type.accessLevel }} func {{ method.name }} async throws {% if method.returnTypeName.name != "Void" %}-> {{ method.returnTypeName.name }} {% endif %}{
        try {{ method.shortName }}ResultToBeReturned.get()
    }
    {% endfor %}
}
{% endfor %}